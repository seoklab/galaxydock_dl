!-------------------------------------------------------------------------------
! Copyright (C) 2015, Lab of Computational Biology and Biomolecular Engineering
!
! File: $GALAXY/src/energy/ppdock/conserve_score.f90
!
! Description:
! 
! 1. For Conservation score calculation, PSSM generated by PSI-BLAST is 
! required.
!
! 2. Conservation energy can be described approximately by analytic function,
! by setting logical variable [conserve_analytic] as [.true.].
!
!-------------------------------------------------------------------------------
!  Reference : Liang, S. et. al. Consensus scoring for enriching near-native 
!              structures from protein-protein docking decoys, 
!              Proteins 2009, 75, 397-403.
!-------------------------------------------------------------------------------
MODULE CONSERVE_SCORE
!-------------------------------------------------------------------------------

use globals
use logger
use mathfunctions, only: sigmoidal1, sigmoidal2
use string, only: parse_longstring
use convert_res_name, only: find_short_res_name, convert_to_stdres
use energy_vars, only: use_conserve, blastfile_defined, blastfile, R

implicit none
save
private

character(len=4), parameter :: res_type(20) = &
       (/ 'ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU', 'GLY', 'ILE', 'LEU', &
       'LYS', 'MET', 'PHE', 'PRO', 'TRP', 'VAL', 'SER', 'THR', 'TYR', 'HIS' /)
! Parameters for analytic ENDES score
real(dp), parameter :: c_exp_H = 20.0d0*pi
real(dp), parameter :: c_exp_F = 20.0d0*pi
!  
real(dp), parameter :: R_inter_sqr = 225.0d0
integer, parameter :: len_pssm = 200
!
integer, allocatable :: res_id(:), Mir(:)
real(dp), allocatable :: E_consres(:)

public :: initialize_conserve_energy
public :: finalize_conserve_energy
public :: calc_conserve_score

CONTAINS
!-------------------------------------------------------------------------------
subroutine initialize_conserve_energy(protein)
!-------------------------------------------------------------------------------
! Initialize conservation score
! res_id, Mir, E_consrse are allocated here. (array_size = protein%n_res)
!-------------------------------------------------------------------------------
type(molecule_type), intent(in) :: protein
integer :: i_res
character(len=4) :: res_name

! Check that pssm file is given or not.
if (.not. blastfile_defined) then
    call terminate_with_error('ERROR: Blastfile is not defined. Insert input : blastfile [filename]')
end if

! allocate variables
allocate(res_id(protein%n_res))
allocate(Mir(protein%n_res))
allocate(E_consres(protein%n_res))

do i_res = 1, protein%n_res
    res_name = protein%residue(i_res)%res_name
    call convert_to_stdres(res_name)
    call find_res_id(res_name, res_id(i_res))
end do

call read_blast_out(protein, blastfile, Mir(1:protein%n_res))
call calc_init_score()
  
end subroutine initialize_conserve_energy
!-------------------------------------------------------------------------------
subroutine finalize_conserve_energy()
!-------------------------------------------------------------------------------
deallocate(res_id, Mir)
deallocate(E_consres)

end subroutine finalize_conserve_energy
!-------------------------------------------------------------------------------
subroutine read_blast_out(protein, blastfile, Mir_temp)
!-------------------------------------------------------------------------------
type(molecule_type), intent(in) :: protein
character(len=len_fname), intent(in) :: blastfile
integer, intent(out) :: Mir_temp(:)
integer :: f_unit, ioerror, num_word, openstat
integer :: i_res, resno, i_loc, PSSM_line(20), n_failed
character(len=len_pssm) :: line
character(len=len_fname) :: word(50), keyword
character(len=1) :: res_word
logical :: found

f_unit = 33
open(f_unit, file = trim(blastfile), iostat = openstat)
if (openstat > 0) then
    call terminate_with_error('ERROR: Blastfile is not found. Please check {blastfile_rec[lig]}.')
end if

i_res = 0
n_failed = 0
do
    read(f_unit, "(A200)", iostat=ioerror) line
    if (ioerror < 0) exit

    call parse_longstring(line, num_word, word, len_pssm)
    keyword = word(1)
    if (keyword == 'Last' .or. keyword == 'A' .or. num_word < 40) cycle

    read(line,*) resno, res_word, PSSM_line(1:20)
    i_res = i_res + 1
    call find_selfscore(protein%residue(i_res), i_res, res_word, i_loc, found)
    if (found) then
        Mir_temp(i_res) = PSSM_line(i_loc)
    else
        Mir_temp(i_res) = 0
        n_failed = n_failed + 1
        if (n_failed > 5) then
            call log_p('Warning: Number of inconsistent residues in blastfile is more thant 5.')
            call log_p('Conservation score is turned off. Please check your blastfile.')
            use_conserve = .false.
            call finalize_conserve_energy()
            exit
        end if
    end if
end do
  
close(f_unit)

end subroutine read_blast_out
!-------------------------------------------------------------------------------
subroutine find_selfscore(residue, i_res, res_word2, i_loc, found)
!-------------------------------------------------------------------------------
type(residue_type), intent(in) :: residue
integer, intent(in) :: i_res
character(len=1), intent(in) :: res_word2
integer, intent(out) :: i_loc
logical, intent(out) :: found
character(len=1), parameter :: res_word_order(20) = &
       (/ 'A','R','N','D','C','Q','E','G','H','I', &
          'L','K','M','F','P','S','T','W','Y','V' /)
character(len=1) :: res_word1
character(len=4) :: res_name
integer :: i_aa
  
found = .true.
res_name = residue%res_name

call convert_to_stdres(res_name)
call find_short_res_name(res_word1, res_name)

if (res_word1 /= res_word2) then
    write(log_msg,"(A,I4)") 'Warning!! Inconsistent residue type on BLAST outfile at ', i_res
    call log_p(log_msg, level=20)
    found = .false.
end if

do i_aa = 1, 20
    if (res_word_order(i_aa) == res_word2) then
        i_loc = i_aa
        exit
    end if
end do

end subroutine find_selfscore
!-------------------------------------------------------------------------------
subroutine calc_init_score()
!-------------------------------------------------------------------------------
integer :: Brr, i_res
character(len=1) :: aa

E_consres(:) = 0.0d0

do i_res = 1, tn%stdres
    call find_short_res_name(aa, res_type(res_id(i_res)))
    call blosum62(aa, aa, Brr)
    if (Mir(i_res) > Brr) then
        E_consres(i_res) = Mir(i_res) - Brr
    end if
end do

end subroutine calc_init_score
!-------------------------------------------------------------------------------
subroutine calc_conserve_score(f, g, is_interres, calc_g)
!-------------------------------------------------------------------------------
logical, intent(in) :: is_interres(tn%stdres), calc_g
real(dp), intent(out) :: f, g(3,tn%stdatm)
real(dp), parameter :: Fcut1 = 0.0d0, Fcut2 = 0.2d0
real(dp) :: dCdr(3,tn%stdres), dHdr(3,tn%stdres)
real(dp) :: Hsum, Hij, F_i, c_F
real(dp) :: r_sqr, r_abs, R_ij(3), argv(3)
real(dp) :: r_cut, r_inter
integer :: res1, res2, i_res
real(dp) :: fv(2)
real(dp), parameter :: wcons = 0.6d0 ! weight factor of original PINUP paper

f = 0.0d0
g(:,:) = 0.0d0
dCdr(:,:) = 0.0d0

r_cut = sqrt(R_inter_sqr) - 10.0d0*pi/c_exp_H
r_inter = sqrt(R_inter_sqr)
c_F = c_exp_F*c_exp_H

! Calculate sum of H-function
do res1 = 1, tn%stdres
    if (.not. is_interres(res1)) cycle

    Hsum = 0.0d0
    dHdr(:,:) = 0.0d0
    do res2 = 1, tn%stdres
        ! Ignore non-interface residue or residue pair in same subunit
        if (.not. is_interres(res2)) cycle
        if ((res1 <= tn%recres .and. res2 <= tn%recres) .or. &
             (res1 > tn%recres .and. res2 > tn%recres)) cycle

        R_ij(:) = R(:,res_index(res2)%Ca_id(1)) - R(:,res_index(res1)%Ca_id(1))
        r_sqr = dot_product(R_ij(:), R_ij(:))
        if (r_sqr > R_inter_sqr) cycle

        r_abs = sqrt(r_sqr)
        if (r_abs > r_cut) then
            fv(:) = sigmoidal2(r_abs, r_cut, r_inter, calc_g)
            Hij = fv(1)
            Hsum = Hsum + Hij
            if (calc_g) then
                argv(:) = fv(2)*R_ij(:)/r_abs
                dHdr(:,res1) = dHdr(:,res1) + argv(:)
                dHdr(:,res2) = dHdr(:,res2) - argv(:)
            end if
        else
            Hsum = Hsum + 1.0d0
        end if

        !If Hsum > 1.0, gradient becomes 0 & F becomes 1
        if (Hsum >= 1.0d0) exit
    end do

    fv(:) = sigmoidal1(Hsum, Fcut1, Fcut2, calc_g)
    F_i = fv(1)
    if (F_i > 0.0d0) then
        f = f + E_consres(res1)*F_i*wcons
        if (calc_g) then
            dCdr(:,:) = dCdr(:,:) + E_consres(res1)*fv(2)*dHdr(:,:)*wcons
        end if
    end if
end do

f = -f
do i_res = 1, tn%stdres
    g(:,res_index(i_res)%Ca_id(1)) = dCdr(:,i_res)
end do

end subroutine calc_conserve_score
!-------------------------------------------------------------------------------
subroutine find_res_id(res_name, res_id)
!-------------------------------------------------------------------------------
! TODO: if available, remove this subroutine and use core/io/in_out_utils.f90.
character(len=4), intent(in) :: res_name
integer, intent(out) :: res_id
integer :: i_res
  
do i_res = 1, 20
    if (res_type(i_res) == trim(res_name)) then
        res_id = i_res
        exit
    end if
end do
  
end subroutine find_res_id
!-------------------------------------------------------------------------------
subroutine blosum62(aa_1, aa_2, score)
!-------------------------------------------------------------------------------
! BLOSUM62 matrix
!-------------------------------------------------------------------------------
character(len=1), intent(in) :: aa_1, aa_2
integer, intent(out) :: score
integer, parameter :: n_aa = 20
character(len=1) :: aa_type(n_aa)
integer :: i_aa, n1, n2, mtrx(n_aa,n_aa)

aa_type(:) = (/ 'A','R','N','D','Q','C','E','G','H','I','L',&
                'K','M','F','P','S','T','W','Y','V' /)

n1 = 0
n2 = 0

do i_aa = 1, n_aa
    if (aa_1 == aa_type(i_aa)) then
        n1 = i_aa
        exit
    end if
end do

do i_aa = 1, n_aa
    if (aa_2 == aa_type(i_aa)) then
        n2 = i_aa
        exit
    end if
end do

if (n1 == 0 .or. n2 == 0) then
    score = -4
    return
end if

mtrx(:,1)  = (/  4,-1,-2,-2,-1, 0,-1, 0,-2,-1,-1,-1,-1,-2,-1, 1, 0,-3,-2, 0 /)
mtrx(:,2)  = (/ -1, 5, 0,-2, 1,-3, 0,-2, 0,-3,-2, 2,-1,-3,-2,-1,-1,-3,-2,-3 /)
mtrx(:,3)  = (/ -2, 0, 6, 1, 0,-3, 0, 0, 1,-3,-3, 0,-2,-3,-2, 1, 0,-4,-2,-3 /)
mtrx(:,4)  = (/ -2,-2, 1, 6, 0,-3, 2,-1,-1,-3,-4,-1,-3,-3,-1, 0,-1,-4,-3,-3 /)
mtrx(:,5)  = (/ -1, 1, 0, 0, 5,-3, 2,-2, 0,-3,-2, 1, 0,-3,-1, 0,-1,-2,-1,-2 /)
mtrx(:,6)  = (/  0,-3,-3,-3,-3, 9,-4,-3,-3,-1,-1,-3,-1,-2,-3,-1,-1,-2,-2,-1 /)
mtrx(:,7)  = (/ -1, 0, 0, 2, 2,-4, 5,-2, 0,-3,-3, 1,-2,-3,-1, 0,-1,-3,-2,-2 /)
mtrx(:,8)  = (/  0,-2, 0,-1,-2,-3,-2, 6,-2,-4,-4,-2,-3,-3,-2, 0,-2,-2,-3,-3 /)
mtrx(:,9)  = (/ -2, 0, 1,-1, 0,-3, 0,-2, 8,-3,-3,-1,-2,-1,-2,-1,-2,-2, 2,-3 /)
mtrx(:,10) = (/ -1,-3,-3,-3,-3,-1,-3,-4,-3, 4, 2,-3, 1, 0,-3,-2,-1,-3,-1, 3 /)
mtrx(:,11) = (/ -1,-2,-3,-4,-2,-1,-3,-4,-3, 2, 4,-2, 2, 0,-3,-2,-1,-2,-1, 1 /)
mtrx(:,12) = (/ -1, 2, 0,-1, 1,-3, 1,-2,-1,-3,-2, 5,-1,-3,-1, 0,-1,-3,-2,-2 /)
mtrx(:,13) = (/ -1,-1,-2,-3, 0,-1,-2,-3,-2, 1, 2,-1, 5, 0,-2,-1,-1,-1,-1, 1 /)
mtrx(:,14) = (/ -2,-3,-3,-3,-3,-2,-3,-3,-1, 0, 0,-3, 0, 6,-4,-2,-2, 1, 3,-1 /)
mtrx(:,15) = (/ -1,-2,-2,-1,-1,-3,-1,-2,-2,-3,-3,-1,-2,-4, 7,-1,-1,-4,-3,-2 /)
mtrx(:,16) = (/  1,-1, 1, 0, 0,-1, 0, 0,-1,-2,-2, 0,-1,-2,-1, 4, 1,-3,-2,-2 /)
mtrx(:,17) = (/  0,-1, 0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1, 1, 5,-2,-2, 0 /)
mtrx(:,18) = (/ -3,-3,-4,-4,-2,-2,-3,-2,-2,-3,-2,-3,-1, 1,-4,-3,-2,11, 2,-3 /)
mtrx(:,19) = (/ -2,-2,-2,-3,-1,-2,-2,-3, 2,-1,-1,-2,-1, 3,-3,-2,-2, 2, 7,-1 /)
mtrx(:,20) = (/  0,-3,-3,-3,-2,-1,-2,-3,-3, 3, 1,-2, 1,-1,-2,-2, 0,-3,-1, 4 /)
score = mtrx(n1,n2)

end subroutine blosum62
!-------------------------------------------------------------------------------
END MODULE CONSERVE_SCORE
